<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HDSP - Laboratorio de Deep Learning on Carlos Hinojosa</title>
    <link>http://carloshinojosa.me/courses/deep-learning-labs/</link>
    <description>Recent content in HDSP - Laboratorio de Deep Learning on Carlos Hinojosa</description>
    <generator>Source Themes academia (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <copyright>&amp;copy; All right reserved by Carlos Hinojosa, {year}</copyright>
    <lastBuildDate>Tue, 02 Jun 2020 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="http://carloshinojosa.me/courses/deep-learning-labs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Google Colaboratory</title>
      <link>http://carloshinojosa.me/courses/deep-learning-labs/colab/</link>
      <pubDate>Mon, 29 Jun 2020 00:00:00 +0100</pubDate>
      
      <guid>http://carloshinojosa.me/courses/deep-learning-labs/colab/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://colab.research.google.com/github/carlosh93/carlosh93.github.io/blob/master/files/introduccion_colab.ipynb&#34;&gt;&lt;img src=&#34;https://colab.research.google.com/assets/colab-badge.svg&#34; alt=&#34;Open In Colab&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Antes de empezar, da click en el boton &amp;ldquo;Open in Colab&amp;rdquo; de arriba. Esto abrirá este notebook de python directamente en Colab. Luego, para poder editar y ejecutar el código, deberas copiar el notebook en Google drive utilizando el boton:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/carlosh93/carlosh93.github.io/master/files/notebook_files/copy_drive.png&#34; alt=&#34;texto alternativo&#34;&gt;&lt;/p&gt;
&lt;p&gt;De esta manera, este notebook quedará almacenado en Google drive, en la carpeta &lt;em&gt;Colab Notebooks&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;introducción&#34;&gt;Introducción&lt;/h2&gt;
&lt;p&gt;El objetivo de este tutorial es proporcionar un flujo de trabajo para entrenar modelos de Deep Learning. El flujo de trabajo propuesto requiere tener instalado los siguientes componentes en nuestra computadora:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cliente de sincronización de Google Drive.&lt;/li&gt;
&lt;li&gt;Editor de texto o IDE de python como Pycharm.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;La idea general será tener nuestro código python en una carpeta en Google Drive. De esta manera, utilizaremos el cliente de sincronización para modificar los archivos de manera local en nuestras computadoras (utilizando el editor de texto o un IDE de python) y que los cambios se vean reflejados directamente en Colab.&lt;/strong&gt; Aunque Colab permite editar archivos (simplemente dando doble click en el archivo deseado en el menu de la izquierda) es mucho mas sencillo y cómodo editar y manipular archivos complejos en un IDE de python.&lt;/p&gt;
&lt;h3 id=&#34;cliente-google-drive&#34;&gt;Cliente Google Drive&lt;/h3&gt;
&lt;p&gt;Para sistemas operativos Windows y Mac el cliente de Google drive puede ser descargado directamente de la pagina de google drive&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.google.com/drive/download/&#34;&gt;https://www.google.com/drive/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Sin embargo, para sistemas operativos Linux no existe un cliente oficial de google drive, pero existen alternativas excelentes como Insync (Software pago una única vez) o el cliente para sistemas Ubuntu:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://cambiatealinux.com/instalar-google-drive-en-ubuntu&#34;&gt;https://cambiatealinux.com/instalar-google-drive-en-ubuntu&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;editor-de-python&#34;&gt;Editor de Python&lt;/h3&gt;
&lt;p&gt;Para trabajar con proyectos Python, es recomendable utilizar el entorno de desarrollo integrado (IDE) Pycharm. Actualmente, es posible acceder a una licencia de estudiante de la version profesional de Pycharm por un año:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com/es-es/community/education/#students&#34;&gt;https://www.jetbrains.com/es-es/community/education/#students&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Para acceder al beneficio solo se necesita el correo electronico institucional (@correo.uis.edu.co o @saber.uis.edu.co o @uis.edu.co).&lt;/p&gt;
&lt;p&gt;Si no se desea utilizar un IDE, es posible trabajar con un editor avanzado de texto: Visual Studio Code:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;https://code.visualstudio.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Note que, debido a que nuestra intención es solo modificar el código en nuestra computadora local y ejecutar el código en Colab, no necesitamos tener instalado Python y las librerias de Tensorflow en nuestra computadora ya que estas se encuentran instaladas en Colab. Sin embargo, es recomendable instalar Python (Anaconda) y configurarlo con Pycharm en nuestra computadora local. A continuación proporciono links de interes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Instalar Anaconda: Windows: &lt;a href=&#34;https://docs.anaconda.com/anaconda/install/windows/&#34;&gt;https://docs.anaconda.com/anaconda/install/windows/&lt;/a&gt;, Linux: &lt;a href=&#34;https://docs.anaconda.com/anaconda/install/linux/&#34;&gt;https://docs.anaconda.com/anaconda/install/linux/&lt;/a&gt;, Mac: &lt;a href=&#34;https://docs.anaconda.com/anaconda/install/mac-os/&#34;&gt;https://docs.anaconda.com/anaconda/install/mac-os/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configurar Pycharm con Anaconda: &lt;a href=&#34;https://docs.anaconda.com/anaconda/user-guide/tasks/pycharm/&#34;&gt;https://docs.anaconda.com/anaconda/user-guide/tasks/pycharm/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instalar liberias de Deep Learning: &lt;a href=&#34;https://asociacionaepi.es/primeros-pasos-con-tensorflow/&#34;&gt;https://asociacionaepi.es/primeros-pasos-con-tensorflow/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;solicitar-recursos-a-colab&#34;&gt;Solicitar Recursos a Colab&lt;/h2&gt;
&lt;p&gt;Una vez creemos un notebook en Colab, para solicitar recursos debemos primero seleccionar el entorno de ejecución adecuado y dar click en el botón Conectar:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/carlosh93/carlosh93.github.io/master/files/notebook_files/sel_entorno_conect.gif&#34; alt=&#34;texto alternativo&#34;&gt;&lt;/p&gt;
&lt;p&gt;Una vez conectados, Colab nos asigna un entorno &lt;strong&gt;Linux con 25.51 GB de Ram, 68 GB de disco duro&lt;/strong&gt; y una GPU cuyas caracteristicas podemos consultar ejecutando la siguiente celda&lt;/p&gt;
&lt;h3 id=&#34;características-de-la-gpu-asignada&#34;&gt;Características de la GPU asignada&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Check nvidia and nvcc cuda compiler

!nvidia-smi
!/usr/local/cuda/bin/nvcc --version
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Tue May 19 00:16:53 2020       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 440.82       Driver Version: 418.67       CUDA Version: 10.1     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  Tesla P100-PCIE...  Off  | 00000000:00:04.0 Off |                    0 |
| N/A   34C    P0    26W / 250W |      0MiB / 16280MiB |      0%      Default |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID   Type   Process name                             Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2019 NVIDIA Corporation
Built on Sun_Jul_28_19:07:16_PDT_2019
Cuda compilation tools, release 10.1, V10.1.243
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por lo general, Colab asigna de manera aleatoria GPUs con diferente cantidad de memoria. Es recomendable utilizar una GPU de 16 o 15 GB de memoria para proyectos que requieran mucha memoria o trabajen con muchos datos. En caso de que Colab no nos asigne una GPU adecuada (algunas veces asigna GPUs de 8 o 11 GB de memoria) para nuestro proyecto, siempre podemos realizar distintas solicitudes hasta conseguir una GPU adecuada. Para esto debemos cerrar la sesion actual y volver a solicitar recursos:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/carlosh93/carlosh93.github.io/master/files/notebook_files/get_new_GPU.gif&#34; alt=&#34;texto alternativo&#34;&gt;&lt;/p&gt;
&lt;p&gt;Este proceso se repite varias veces hasta que se nos asigne la GPU deseada. Note que es posible que requiera recargar la ventana (F5) para poder finalizar la sesion. &lt;strong&gt;OJO&lt;/strong&gt; Esto solo es necesario hacerlo si necesitamos una GPU de un tamaño de memoria especifico. Si nuestro proyecto es pequeño, cualquier GPU asignada por Colab servirá.&lt;/p&gt;
&lt;p&gt;Nota: Este notebook está pre-configurado para trabajar con 25 Gb de memoria RAM, sin embargo esta configuración no es por defecto. La cantidad de memoria asignada por general es de 12 a 16 GB. Si crea un notebook nuevo en Colab y quiere tener 25 GB ver sección de Bonus al final de este tutorial.&lt;/p&gt;
&lt;h3 id=&#34;comandos-básicos&#34;&gt;Comandos Básicos&lt;/h3&gt;
&lt;p&gt;Debido a que cada notebook de Colab se ejecuta en una máquina Linux, es posible utilizar todos los comandos de Linux. Los comandos más básicos para movernos dentro de este tipo de ambiente son:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%pwd # Ver el directorio actual de trabajo
%ls # Listar los archivos del directorio actual
%cd # Cambiar de directorio
%mkdir # Crear un nuevo directorio
%rmdir # Eliminar un directorio vacio
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por ejemplo, si quiero ver en que carpeta me encuentro actualmente ejecuto una celda con el comando:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%pwd
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&#39;/content&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como vemos, me encuentro en la carpeta &amp;lsquo;/content&amp;rsquo;, es decir, la carpeta raiz de Colab. Adicionalmente, podemos ejecutar varios comandos dentro de una celda agregando %%shell al inicio de esta. Por ejemplo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%%shell
pwd
ls
mkdir &amp;quot;nuevo_directorio&amp;quot;
ls
rmdir &amp;quot;nuevo_directorio&amp;quot;
ls
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/content
sample_data
nuevo_directorio  sample_data
sample_data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note que si se agrega &lt;em&gt;%%shell&lt;/em&gt; al inicio, se debe quitar el simbolo % al principio de cada comando. Así, en vez de escribir &lt;em&gt;%pwd&lt;/em&gt;, escribimos &lt;em&gt;pwd&lt;/em&gt; solamente. Note ademas, que el resultado de cada comando se muestra en una linea aparte. De esta manera, el primer comando ls, muestra el contenido de la carpeta /content, que en este caso es solo la carpeta &amp;lsquo;sample_data/&amp;rsquo;. Luego creamos la carpeta &amp;lsquo;nuevo_directorio&amp;rsquo; (observe que el comando mkdir no arroja ninguna salida), listamos el contenido de content/ para ver la nueva carpeta creada y por ultimo borramos la carpeta.&lt;/p&gt;
&lt;p&gt;En general se puede utilizar cualquier comando linux, incluso instalar paquetes linux con el software apt, por ejemplo:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%%shell
sudo apt install nano
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%%shell
sudo apt install nano
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Reading package lists... Done
Building dependency tree       
Reading state information... Done
Suggested packages:
  spell
The following NEW packages will be installed:
  nano
0 upgraded, 1 newly installed, 0 to remove and 31 not upgraded.
Need to get 231 kB of archives.
After this operation, 778 kB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu bionic/main amd64 nano amd64 2.9.3-2 [231 kB]
Fetched 231 kB in 2s (130 kB/s)
debconf: unable to initialize frontend: Dialog
debconf: (No usable dialog-like program is installed, so the dialog based frontend cannot be used. at /usr/share/perl5/Debconf/FrontEnd/Dialog.pm line 76, &amp;lt;&amp;gt; line 1.)
debconf: falling back to frontend: Readline
debconf: unable to initialize frontend: Readline
debconf: (This frontend requires a controlling tty.)
debconf: falling back to frontend: Teletype
dpkg-preconfigure: unable to re-open stdin: 
Selecting previously unselected package nano.
(Reading database ... 144433 files and directories currently installed.)
Preparing to unpack .../nano_2.9.3-2_amd64.deb ...
Unpacking nano (2.9.3-2) ...
Setting up nano (2.9.3-2) ...
update-alternatives: using /bin/nano to provide /usr/bin/editor (editor) in auto mode
update-alternatives: using /bin/nano to provide /usr/bin/pico (pico) in auto mode
Processing triggers for man-db (2.8.3-2ubuntu0.1) ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Puede buscar mas comandos en internet, una pagina inicial sería:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://marcosmarti.org/comandos-basicos-de-linux/&#34;&gt;https://marcosmarti.org/comandos-basicos-de-linux/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;setup&#34;&gt;Setup&lt;/h2&gt;
&lt;p&gt;Lo primero que haremos será conectarnos con nuestra cuenta de Google Drive. &lt;strong&gt;Importante conectarse a la cuenta de google drive en donde se tiene almacenado el proyecto o el código a ejecutar.&lt;/strong&gt; Adicionalmente, esta cuenta debe estar previamente sincronizada en nuestra computadora utilizando un cliente de Google Drive (Ver Introducción). Para conectarnos a google drive, ejecutamos la celda de abajo y seguimos los pasos. Por favor seleccione la cuenta previamente sincronizada.&lt;/p&gt;
&lt;h3 id=&#34;mount-goolge-drive&#34;&gt;Mount Goolge Drive&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# link to google drive

from google.colab import drive
#drive.mount(&#39;/content/gdrive/&#39;)
drive.mount(&amp;quot;/content/gdrive/&amp;quot;, force_remount=True)
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Go to this URL in a browser: https://accounts.google.com/o/oauth2/auth?client_id=947318989803-6bn6qk8qdgf4n4g3pfee6491hc0brc4i.apps.googleusercontent.com&amp;amp;redirect_uri=urn%3aietf%3awg%3aoauth%3a2.0%3aoob&amp;amp;response_type=code&amp;amp;scope=email%20https%3a%2f%2fwww.googleapis.com%2fauth%2fdocs.test%20https%3a%2f%2fwww.googleapis.com%2fauth%2fdrive%20https%3a%2f%2fwww.googleapis.com%2fauth%2fdrive.photos.readonly%20https%3a%2f%2fwww.googleapis.com%2fauth%2fpeopleapi.readonly

Enter your authorization code:
··········
Mounted at /content/gdrive/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Si damos click en el panel de la izquierda, al icono de carpeta, veremos que tenemos una nueva carpeta llamada &amp;lsquo;gdrive&amp;rsquo;. De esta manera habremos sincronizado de manera correcta google drive con Colab.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/carlosh93/carlosh93.github.io/master/files/notebook_files/ver_gdrive.png&#34; alt=&#34;texto alternativo&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ahora la idea es trabajar en nuestro código. Existen básicamente dos maneras:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Añadir el codigo directamente en este notebook e ir ejecutando cada celda.&lt;/li&gt;
&lt;li&gt;Ejecutar un script de python directamente desde una celda.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;En este tutorial se utilizará la segunda forma. Para esto utilicé como ejemplo el tutorial de tensorflow:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tensorflow.org/tensorboard/get_started&#34;&gt;https://www.tensorflow.org/tensorboard/get_started&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Seguidamente, creé un proyecto en mi computadora local llamado colab_tutorial. La carpeta de este proyecto se encuentra sincronizado con mi Google Drive, por lo tanto, todo cambio que se realice en mi computadora local se vera reflejado directamente en Drive y, de igual forma, en Colab.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/carlosh93/carlosh93.github.io/master/files/notebook_files/screen_pycharm.png&#34; alt=&#34;texto alternativo&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/carlosh93/carlosh93.github.io/master/files/notebook_files/carpeta_google_drive.png&#34; alt=&#34;texto alternativo&#34;&gt;&lt;/p&gt;
&lt;p&gt;Una vez tengamos listo el código en nuestra carpeta local, solo basta con ejecutar una celda de la siguiente forma&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;!python3 nombre_archivo.py --parametros (opcional)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;De esta forma ejecutaremos nuestro código en Colab. Note que nuestro código tambien puede generar salidas, las cuales (si se almacenan dentro de la misma carpeta del proyecto) quedarán sincronizadas con nuestra computadora local.&lt;/p&gt;
&lt;p&gt;Aqui un ejemplo de ejecutar la funcion main.py dentro de mi carpeta proyecto &amp;ldquo;colab_tutorial&amp;rdquo;. Primero vamos hacia la carpeta con los comandos básicos explicados en la sección 2.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%cd /content/gdrive/My\ Drive/colab_tutorial/
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;/content/gdrive/My Drive/colab_tutorial
&lt;/code&gt;&lt;/pre&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%ls
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;main.py
&lt;/code&gt;&lt;/pre&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;!python main.py
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;2020-05-19 01:24:56.751869: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcudart.so.10.1
2020-05-19 01:24:58.852417: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcuda.so.1
2020-05-19 01:24:58.866042: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:58.866658: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1561] Found device 0 with properties: 
pciBusID: 0000:00:04.0 name: Tesla P100-PCIE-16GB computeCapability: 6.0
coreClock: 1.3285GHz coreCount: 56 deviceMemorySize: 15.90GiB deviceMemoryBandwidth: 681.88GiB/s
2020-05-19 01:24:58.866696: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcudart.so.10.1
2020-05-19 01:24:58.868230: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcublas.so.10
2020-05-19 01:24:58.869913: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcufft.so.10
2020-05-19 01:24:58.870253: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcurand.so.10
2020-05-19 01:24:58.871814: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcusolver.so.10
2020-05-19 01:24:58.872594: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcusparse.so.10
2020-05-19 01:24:58.875551: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcudnn.so.7
2020-05-19 01:24:58.875654: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:58.876241: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:58.876770: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1703] Adding visible gpu devices: 0
2020-05-19 01:24:58.881933: I tensorflow/core/platform/profile_utils/cpu_utils.cc:102] CPU Frequency: 2200000000 Hz
2020-05-19 01:24:58.882377: I tensorflow/compiler/xla/service/service.cc:168] XLA service 0x138f100 initialized for platform Host (this does not guarantee that XLA will be used). Devices:
2020-05-19 01:24:58.882409: I tensorflow/compiler/xla/service/service.cc:176]   StreamExecutor device (0): Host, Default Version
2020-05-19 01:24:58.960753: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:58.961607: I tensorflow/compiler/xla/service/service.cc:168] XLA service 0x138ef40 initialized for platform CUDA (this does not guarantee that XLA will be used). Devices:
2020-05-19 01:24:58.961643: I tensorflow/compiler/xla/service/service.cc:176]   StreamExecutor device (0): Tesla P100-PCIE-16GB, Compute Capability 6.0
2020-05-19 01:24:58.961839: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:58.962429: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1561] Found device 0 with properties: 
pciBusID: 0000:00:04.0 name: Tesla P100-PCIE-16GB computeCapability: 6.0
coreClock: 1.3285GHz coreCount: 56 deviceMemorySize: 15.90GiB deviceMemoryBandwidth: 681.88GiB/s
2020-05-19 01:24:58.962471: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcudart.so.10.1
2020-05-19 01:24:58.962526: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcublas.so.10
2020-05-19 01:24:58.962541: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcufft.so.10
2020-05-19 01:24:58.962554: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcurand.so.10
2020-05-19 01:24:58.962566: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcusolver.so.10
2020-05-19 01:24:58.962581: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcusparse.so.10
2020-05-19 01:24:58.962596: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcudnn.so.7
2020-05-19 01:24:58.962655: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:58.963213: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:58.963746: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1703] Adding visible gpu devices: 0
2020-05-19 01:24:58.963791: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcudart.so.10.1
2020-05-19 01:24:59.498013: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1102] Device interconnect StreamExecutor with strength 1 edge matrix:
2020-05-19 01:24:59.498074: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1108]      0 
2020-05-19 01:24:59.498084: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1121] 0:   N 
2020-05-19 01:24:59.498276: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:59.498864: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:981] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2020-05-19 01:24:59.499412: W tensorflow/core/common_runtime/gpu/gpu_bfc_allocator.cc:39] Overriding allow_growth setting because the TF_FORCE_GPU_ALLOW_GROWTH environment variable is set. Original config value was 0.
2020-05-19 01:24:59.499466: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1247] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 14973 MB memory) -&amp;gt; physical GPU (device: 0, name: Tesla P100-PCIE-16GB, pci bus id: 0000:00:04.0, compute capability: 6.0)
2020-05-19 01:24:59.547390: I tensorflow/core/profiler/lib/profiler_session.cc:159] Profiler session started.
2020-05-19 01:24:59.547453: I tensorflow/core/profiler/internal/gpu/cupti_tracer.cc:1363] Profiler found 1 GPUs
2020-05-19 01:24:59.548374: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcupti.so.10.1
2020-05-19 01:24:59.678606: I tensorflow/core/profiler/internal/gpu/cupti_tracer.cc:1479] CUPTI activity buffer flushed
Epoch 1/10
2020-05-19 01:25:00.110434: I tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library libcublas.so.10
2020-05-19 01:25:00.407164: I tensorflow/core/profiler/lib/profiler_session.cc:159] Profiler session started.
   1/1875 [..............................] - ETA: 0s - loss: 2.5025 - accuracy: 0.0000e+002020-05-19 01:25:00.411242: I tensorflow/core/profiler/internal/gpu/cupti_tracer.cc:1479] CUPTI activity buffer flushed
2020-05-19 01:25:00.411386: I tensorflow/core/profiler/internal/gpu/device_tracer.cc:216]  GpuTracer has collected 62 callback api events and 62 activity events.
2020-05-19 01:25:00.424149: I tensorflow/core/profiler/rpc/client/save_profile.cc:168] Creating directory: logs/fit/20200519-012459/train/plugins/profile/2020_05_19_01_25_00
2020-05-19 01:25:00.430074: I tensorflow/core/profiler/rpc/client/save_profile.cc:174] Dumped gzipped tool data for trace.json.gz to logs/fit/20200519-012459/train/plugins/profile/2020_05_19_01_25_00/998f21424347.trace.json.gz
2020-05-19 01:25:00.430893: I tensorflow/core/profiler/utils/event_span.cc:288] Generation of step-events took 0.016 ms

2020-05-19 01:25:00.449145: I tensorflow/python/profiler/internal/profiler_wrapper.cc:87] Creating directory: logs/fit/20200519-012459/train/plugins/profile/2020_05_19_01_25_00Dumped tool data for overview_page.pb to logs/fit/20200519-012459/train/plugins/profile/2020_05_19_01_25_00/998f21424347.overview_page.pb
Dumped tool data for input_pipeline.pb to logs/fit/20200519-012459/train/plugins/profile/2020_05_19_01_25_00/998f21424347.input_pipeline.pb
Dumped tool data for tensorflow_stats.pb to logs/fit/20200519-012459/train/plugins/profile/2020_05_19_01_25_00/998f21424347.tensorflow_stats.pb
Dumped tool data for kernel_stats.pb to logs/fit/20200519-012459/train/plugins/profile/2020_05_19_01_25_00/998f21424347.kernel_stats.pb

1875/1875 [==============================] - 5s 3ms/step - loss: 0.2168 - accuracy: 0.9365 - val_loss: 0.1001 - val_accuracy: 0.9694
Epoch 2/10
1875/1875 [==============================] - 5s 3ms/step - loss: 0.0948 - accuracy: 0.9710 - val_loss: 0.0865 - val_accuracy: 0.9725
Epoch 3/10
1875/1875 [==============================] - 5s 3ms/step - loss: 0.0670 - accuracy: 0.9786 - val_loss: 0.0708 - val_accuracy: 0.9778
Epoch 4/10
1875/1875 [==============================] - 5s 2ms/step - loss: 0.0525 - accuracy: 0.9832 - val_loss: 0.0623 - val_accuracy: 0.9810
Epoch 5/10
1875/1875 [==============================] - 5s 2ms/step - loss: 0.0433 - accuracy: 0.9855 - val_loss: 0.0696 - val_accuracy: 0.9806
Epoch 6/10
1875/1875 [==============================] - 5s 2ms/step - loss: 0.0357 - accuracy: 0.9885 - val_loss: 0.0685 - val_accuracy: 0.9816
Epoch 7/10
1875/1875 [==============================] - 5s 2ms/step - loss: 0.0299 - accuracy: 0.9901 - val_loss: 0.0625 - val_accuracy: 0.9822
Epoch 8/10
1875/1875 [==============================] - 5s 2ms/step - loss: 0.0276 - accuracy: 0.9908 - val_loss: 0.0655 - val_accuracy: 0.9821
Epoch 9/10
1875/1875 [==============================] - 5s 2ms/step - loss: 0.0237 - accuracy: 0.9925 - val_loss: 0.0789 - val_accuracy: 0.9806
Epoch 10/10
1875/1875 [==============================] - 5s 2ms/step - loss: 0.0230 - accuracy: 0.9923 - val_loss: 0.0750 - val_accuracy: 0.9827
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En este ejemplo en particular se hizo uso de la herramienta &lt;a href=&#34;https://www.tensorflow.org/tensorboard&#34;&gt;Tensorboard&lt;/a&gt;, el cual proporciona una interfaz de visualización para el entrenamiento de los modelos. Al ejecutar nuestro código, se guarda en la carpeta logs el resultado de entrenamiento para cada epoch. Para visualizar la herramienta Tensorboard tenemos basicamente dos formas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Visualizar Tensorboard directamente en Colab&lt;/li&gt;
&lt;li&gt;Visualizar Tensorboard en nuestra computadora local&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;La desventaja de visualizar en Colab es que debemos esperar a que termine el entrenamiento para visualizar Tensorboard. Por el contrario, debido a que tenemos nuestra carpeta sincronizada, podemos ejecutar Tensorboard en nuestra computadora y visualizar el entrenamiento de manera local en tiempo real mientras se ejecuta el entrenamiento en Colab.&lt;/p&gt;
&lt;p&gt;Para visualizar el resultado directamente en este notebook ejecutamos las siguientes dos celdas. La primera solo se ejecuta una vez, pues es la encargada de cargar la extension.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Load the TensorBoard notebook extension (Ejecutar una sola vez)
%load_ext tensorboard
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%tensorboard --logdir logs/fit
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Reusing TensorBoard on port 6006 (pid 1921), started 0:04:55 ago. (Use &#39;!kill 1921&#39; to kill it.)



&amp;lt;IPython.core.display.Javascript object&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Los detalles de implementación del código utilizado de ejemplo se pueden consultar directamente en la página del tutorial: &lt;a href=&#34;https://www.tensorflow.org/tensorboard/get_started&#34;&gt;https://www.tensorflow.org/tensorboard/get_started&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;conclusiones&#34;&gt;Conclusiones&lt;/h2&gt;
&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;En conclusion, gracias a la sincronización que nos provee el cliente de google drive, podemos hacer todas las modificaciones necesarias de manera local en nuestras computadoras y unicamente utilizar colab para ejecturar el entrenamiento de la red neuronal aprovechando su GPU. Adicionalmente, el uso de la herramienta Tensorboard es fundamental para monitorear el entrenamiento.&lt;/p&gt;
&lt;h3 id=&#34;bonus&#34;&gt;Bonus&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt;
Cuando ejecutamos entrenamientos muy largos, es posible que Colab se desconecte inesperadamente debido a falta de interactividad. Para solucionar este problema podemos agregar un código Javascript en esta página para hacer &amp;ldquo;clicks&amp;rdquo; de manera automática en el boton Conect (Boton donde se muestra uso de RAM y Disco). El código en cuestión es el siguiente:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;function ClickConnect(){
    console.log(&amp;quot;Clicked on connect button&amp;quot;); 
    document.querySelector(&amp;quot;colab-connect-button&amp;quot;).click()
}
setInterval(ClickConnect,60000)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Este código debe agregarse en la consola de Javascript de la siguiente manera:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/carlosh93/carlosh93.github.io/master/files/notebook_files/prevent_disconecting.gif&#34; alt=&#34;texto alternativo&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt; Si se quiere mas memoria ram, se puede ejecutar el siguiente código en una celda:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a = []
while(1):
    a.append(‘1’)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Al ejecutarlo, este comando va a llenar la memoria ram disponible en Colab y forzará a este a ampliar la capacidad. Debemos esperar aproximadamente 1 minuto hasta que salga un letrero que pregunta si deseamos ampliar la memoria. Despues de aceptar, tendremos más memoria RAM en nuestro notebook. Mas información: &lt;a href=&#34;https://towardsdatascience.com/upgrade-your-memory-on-google-colab-for-free-1b8b18e8791d&#34;&gt;https://towardsdatascience.com/upgrade-your-memory-on-google-colab-for-free-1b8b18e8791d&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;tarea&#34;&gt;Tarea&lt;/h2&gt;
&lt;p&gt;Realice las siguientes actividades y elabore un informe con sus análisis y conclusiones&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lea el tutorial descrito en el siguiente enlace:  &lt;a href=&#34;https://www.tensorflow.org/tensorboard/get_started&#34;&gt;https://www.tensorflow.org/tensorboard/get_started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Instale el IDE de python Pycharm y el cliente de Google drive como se describe en este tutorial.&lt;/li&gt;
&lt;li&gt;Implemente el código mostrado en el tutorial &lt;a href=&#34;https://www.tensorflow.org/tensorboard/get_started&#34;&gt;https://www.tensorflow.org/tensorboard/get_started&lt;/a&gt; en un archivo de python (.py).&lt;/li&gt;
&lt;li&gt;Sincronice el código con Google Drive utilizando el cliente de Google drive&lt;/li&gt;
&lt;li&gt;Ejecute el código en Colab y visualice la salida en Tensorboard.&lt;/li&gt;
&lt;li&gt;Utilice el editor Pycharm para modificar el archivo de python donde se implementó el código. Cambie el número de epocas (EPOCHS)
a 10 y vuelva a ejecutar el código.&lt;/li&gt;
&lt;li&gt;Elabore un informe &lt;strong&gt;corto&lt;/strong&gt; donde describa con sus palabras que es Google Colab y que es Tensorboard y para qué sirve estas dos
herramientas.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Machine Learning I</title>
      <link>http://carloshinojosa.me/courses/deep-learning-labs/concepts/</link>
      <pubDate>Tue, 05 May 2020 00:00:00 +0100</pubDate>
      
      <guid>http://carloshinojosa.me/courses/deep-learning-labs/concepts/</guid>
      <description>&lt;p&gt;Antes de inicar con conceptos básicos sobre redes neuronales tensorflow keras etc,  estudiaremos las ideas fundamentales sobre el mundo de la inteligencia artificial.&lt;/p&gt;
&lt;p&gt;La inteligencia artificial se puede definir como la ciencia de entrenar máquinas para ejecutar tareas humanas y machine learning es una parte de la inteligencia artifical encargada de resolver esos problemas.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Image(&#39;ML.PNG&#39;, width = 800)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;../figs/Machine_learning_I_1_0.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Machine Learning es un metodo de análisis para la construcción de modelos automatas, que usan diversos algoritmos para aprender iterativamente de un conjunto de datos historicos.&lt;/p&gt;
&lt;p&gt;Los campos de aplicación de machine learning son muy diversos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Detección de fraudes&lt;/li&gt;
&lt;li&gt;Resultados de motores de busqueda&lt;/li&gt;
&lt;li&gt;Análisis de sentimientos&lt;/li&gt;
&lt;li&gt;Detección de objetos&lt;/li&gt;
&lt;li&gt;Reconocimiento de voz&lt;/li&gt;
&lt;li&gt;Realce de imágenes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Uno de los sistemas de machine learning que ha revolucionado la industria en los ultimos años son las conocidas &lt;strong&gt;redes neuronales.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Las redes neuronales son una forma de modelar matematicamente un neuron biológico. Esto es, son arquitecturas inspiradas en el cerebro humano y en su estructura ampliamente paralela, con capacidad de adquirir, almacenar y utilizar conocimiento experimental, generalizando su conocimiento a partir de ejemplos anteriores.&lt;/p&gt;
&lt;p&gt;En 1943 se lanza el primer modelo computacional para una neurona artificial y es llamado de perceptron.&lt;/p&gt;
&lt;p&gt;El perceptron (Figura 1), es la idea mas simple de un neuron artificial y se puede definir como el conjunto de entradas de una muestra &lt;strong&gt;X&lt;/strong&gt; las cuales representan los estimulos que la neurona recibe del ambiente y que se combinan con los pesos sinápticos &lt;strong&gt;W&lt;/strong&gt; para determinar la entrada del neuron, dicha entrada pasa por una función de activación o umbral que genera una salida &lt;strong&gt;Y&lt;/strong&gt; la cual determinará si el neuron se activa siempre y cuando el valor de la combinacion lineal de sus entradas con los pesos supere el umbral de activación.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Image(&#39;perceptron.PNG&#39;, width = 800)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;../figs/Machine_learning_I_4_0.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;En un neuron podemos codificar información que nos servira para realizar tareas de calsificación prediccion, etc. Sin embargo la figura de un perceptron matematicamente (antes de la funcion de activación), no es mas que un función que realiza un calculo numérico lineal.
Internamente la neurona utiliza todos los valores de entrada para realizar una suma ponderada entre los estimulos &lt;strong&gt;X&lt;/strong&gt; multiplicados por un valor especifico llamado pesos &lt;strong&gt;W&lt;/strong&gt; y que son los parametros y la parte fundamental del proceso de aprendizaje.&lt;/p&gt;
&lt;p&gt;$$Y = x_1w_1 + x_2w_2 + x_3w_3 ..+ ..+ ..+ x_nw_n + b$$&lt;/p&gt;
&lt;p&gt;donde &lt;strong&gt;b&lt;/strong&gt; es el termino independiente de la ecuación y es conocido como &lt;strong&gt;bias&lt;/strong&gt; el cual tomara el control para mover la recta de la función, y es una conección mas a la entrada de cada neurona.&lt;/p&gt;
&lt;p&gt;Si lo ven el modelo matemático de una neurona no es mas que una funcion lineal&lt;/p&gt;
&lt;p&gt;$$ y = aX +b$$&lt;/p&gt;
&lt;p&gt;Una forma práctica de analizar una neurona artificial es simulando una compuerta &lt;strong&gt;and&lt;/strong&gt; donde tenemos dos posibles valores de entrada &lt;strong&gt;x1&lt;/strong&gt; ,  &lt;strong&gt;x2&lt;/strong&gt;  y cuatro posibles combinaciones de salida &lt;strong&gt;y&lt;/strong&gt; que las podemos etiquetar como 0(inactiva) y 1(activa), este nuevo concepto etiqueta es clave en el aprendizaje de máquinas supervisado ya que la neurona aprenderá de los datos históricos o también conocidos como etiquetas ( como se puede ver las etiquetas son los mismos valores de salida).&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Image(&#39;tabla.PNG&#39;, width = 800)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;../figs/Machine_learning_I_6_0.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Pero como se sabe el resultado de usar una regresión lineal entre las combinaciones entre x1 y x2 nos da un resultado  numérico continuo  y no un  número binario, para eso se introducen las llamadas funciones de activación, que en la figura 1 son representadas por la ultima caja del modelo y que utilizaran un umbral para decidir si el valor numérico entregado por la suma ponderada supera dicho umbral se entregará como salida un 1 ( neurona activa) caso contrario será entregado un 0 ( neurona no activa).&lt;/p&gt;
&lt;p&gt;una forma mas simple e intuitiva de ver este problema es tratandolo como un problema de clasificación. Esto es encontrar una recta que separe los valores 0 de los valores 1 como se muestra en la siguiente grafica de una compuerta &lt;strong&gt;and&lt;/strong&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Image(&#39;and.PNG&#39;, width = 500)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;../figs/Machine_learning_I_8_0.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;La linea azul es la linea de regresión que la neurona aprendio despues de alguna etapas de entrenamiento y consiguio encontrar los mejores valores de &lt;strong&gt;W&lt;/strong&gt; para lograr su objetivo ( separar los valores 0 de los valores 1).&lt;/p&gt;
&lt;p&gt;Pero que es el entrenamiento?
el entrenamiento en modelos de machine learning es la aplicacion de un algoritmo de aprendizje através de iteraciones sobre el conjunto de parametros &lt;strong&gt;W&lt;/strong&gt; y &lt;strong&gt;b&lt;/strong&gt; con el fin de actualizarlos en cada iteración reduciendo el error y ahciendo que la salida sea lo mas parecida posible a la etiqueta.&lt;/p&gt;
&lt;p&gt;Estos algoritmos de aprendizaje buscan imitar la la forma en que funcionan las neuronas en el cerebro (si generan pulsos electricos que se trasmitan a otras neuronas o no), se utiliza la formula de aprendizaje que se resume en 2 pasos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inicialización de pesos con valores pequeños&lt;/li&gt;
&lt;li&gt;Para cada muestra de entrada de X se cacula su respectiva salida Y y se actualizan los pesos W de la siguiente manera:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$W_j = W_j + \Delta W_j$$&lt;/p&gt;
&lt;p&gt;donde $\Delta W_j$ es:&lt;/p&gt;
&lt;p&gt;$$\Delta W_j = \eta (Y - \hat {Y}) X_j$$&lt;/p&gt;
&lt;p&gt;donde $Y$ es el valor de la etiqueta original y $\hat {Y}$ es el valor calculado a la salida del perceptron, usando como funcion de activación el escalon unitario.&lt;/p&gt;
&lt;p&gt;#Porque se deben entrenar los modelos de aprendizaje automático?&lt;/p&gt;
&lt;p&gt;A fin de que nuestros algoritmos de aprendizaje automático funcionen de la manera mas adecuada posible (esto es que se ajusten lo mejor posible al problema planteado), se debe llevar a cabo un mapa conceptual de que es lo que se pretende lograr con el modelo y como podemos conseguir que dicho modelo se ajuste a los datos presentados. Esto requiere de mucha practica ya que cada algoritmo lleva caonsigo sus propias caracteristicas y se basa en determinadas suposiciones,  &amp;ldquo;&lt;em&gt;Ningun algoritmo es perfecto todos los modelos estan equivocados pero algunos son utiles. George Eward Pelham&lt;/em&gt; &amp;quot;&lt;/p&gt;
&lt;p&gt;A dia de hoy existen, decenas de frameworks y APIs que nos facilitan crear modelos de aprendizaje automático de una forma simple y eficiente. Pero que hay detras de estos modelos? porque se habla de algoritmos y reglas de aprendizaje? y para que sirve esto?. Pues en este apartado encontraras una simple explicación del porque es importante entrenar los modelos de aprendizaje a través de un ejemplo de regresión lineal.&lt;/p&gt;
&lt;p&gt;Todo parte de un conjunto de datos historicos, el machine learning no existiria si no tuvieramos datos con que entrenar nuestros modelos (&lt;em&gt;&lt;strong&gt;sem dados no há para isso&lt;/strong&gt;&lt;/em&gt; ==&amp;gt; pequeña muestra de un error en un sistema de reconocimiento en portugues cuando pronuncié &lt;em&gt;&lt;strong&gt;sin datos no hay paraiso&lt;/strong&gt;&lt;/em&gt; :-)).&lt;/p&gt;
&lt;p&gt;Como el objetivo es crear un sistema de regresión linela, recurriremos a su formula:&lt;br&gt;
$$ y=WX+b$$&lt;/p&gt;
&lt;p&gt;donde &lt;strong&gt;W&lt;/strong&gt; y &lt;strong&gt;b&lt;/strong&gt; como ya sabemos representan los pesos y bias como son llamados en machine learning o como matematicamente se les conoce la pendiente e intersección de la recta respectivamente, &lt;strong&gt;X&lt;/strong&gt; representa el conjunto de entrada de nuestros sistemas (nuestros datos historicos) y &lt;strong&gt;y&lt;/strong&gt; será el resultado deseado.&lt;/p&gt;
&lt;p&gt;Iniciaremos creando un conjunto de características aleatorias sinteticas que representaran el conjunto de datos de entrada &lt;strong&gt;X&lt;/strong&gt;, suponiendo que se trata de una variable de precio de casas en un barrio por ejemplo.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#importamos las librerias necesarias
import tensorflow as tf

# generamos valores aleatorios de entrada en fomra de tensores
Numero_muestras=1000
X = tf.random.normal(shape=(Numero_muestras,))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ahora crearemos el modelo de regresión lineal, basado en la formula anterior e inicializando los pesos y el bias con valores aleatorios, esto con el fin de mostrar por que es imoprtante el entrenamiento. Atento que mencione &amp;ldquo;&amp;ldquo;inicializar&amp;rdquo;&amp;rdquo;, en todo algoritmo de machine learning en su etapa inicial los pesos y bias se inician con valores aleatorios my pequeños preferiblemente diferentes de zero. En este caso a modo de ejemplo asignaremos unos valores constantes de: &lt;strong&gt;W=16.0&lt;/strong&gt; y &lt;strong&gt;b=10.0&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Regresion(object):
  def __init__(self):
    self.W = tf.Variable(16.0)  # pesos w inicializado en 16
    self.b = tf.Variable(10.0) # bias inicializado en 10

  def __call__(self,X):
    return self.W*X + self.b   # ecuación de la regresión
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;y como por arte de magia el modelo de regresión lineal esta creado de forma muy simple, donde al llamar el metodo call retornaremos nuestra función de regresión previamente explicada.&lt;/p&gt;
&lt;p&gt;Ahora se creará una instancia del modelo y se hará una predicción&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;modelo = Regresion()  # instancia del modelo
modelo(20).numpy()    # en este caso X es la entrada de la redque conocemos y le damos un valor de 20
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;330.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como se puede ver el resultado de la regresión nos dio un valor de 330.0. Pero será este resultado lo que realmente estabamos buscando?, será que el modelo me predijo correctamente lo que se queria?. una forma de averiguarlo es creando un conjunto de datos historicos sinteticos a los cuales les  llamaremos &amp;ldquo;reales&amp;rdquo;. Recordemos que todo sistema de machine learning funciona con datos historicos.
Como estamos trabajando con un sistema supervisado, recrearemos unos valores para &lt;strong&gt;W&lt;/strong&gt; y &lt;strong&gt;b&lt;/strong&gt; ideales para asi poder tener nuestros datos historicos simulados.&lt;/p&gt;
&lt;p&gt;Este es el punto mas importante los datos de &lt;strong&gt;w&lt;/strong&gt; y &lt;strong&gt;b&lt;/strong&gt; no los conocemos si los supieramos no necesitariamos algoritmos de aprendizaje, es por eso que en este ejemplo los idealizamos como si los supieramos para entender el por que es importante la etapa de entrenamiento.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#datos ideales
TRUE_W=3.0
TRUE_b=0.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Para tener un conjunto de datos sinteticos mas reales adicionaremos ruido a nuestros conjunto de datos, esto simulara efecto de datos perdidos en el dataset, datos extremos, datos nulos etc.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;noise =tf.random.normal(shape=(Numero_muestras,))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Con lo anterior creamos nuestro conjunto de datos historico simulado&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;y=X*TRUE_W+TRUE_b + noise
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ahora si, a lo que vinimos, vamos a crear un grafico donde pondremos los datos historicos reales y los datos que el modelo predice. Lo ideal seria encontrar una linea de regresion que este bien por encima de los datos originales&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import matplotlib.pyplot as plt
#grafica de los valores historicos reales
plt.scatter(X,y, label=&amp;quot;valores reales&amp;quot;)
#grafica de los valores predichos por el modelo
plt.scatter(X,modelo(X), label = &amp;quot;valores predichos&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.collections.PathCollection at 0x7f18e6a00a58&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../figs/Machine_learning_I_24_1.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;los puntos en azul representan los valores reales, la linea de regresion naranja son los predichos por el modelo. Pero por que estan tan lejos una de la otra? esto se debe a que los pesos no se actualizaron.&lt;/p&gt;
&lt;p&gt;Ese es nuestro objetivo actualizar los pesos sucesivamente hasta encontrar los que mejor adapten la linea de regresión a los datos historicos. En este caso nuestro modelo deberiá haber encontrado unos pesos de &lt;strong&gt;W=3.0&lt;/strong&gt; y &lt;strong&gt;b=0.5&lt;/strong&gt; esto no se consiguio debido al hecho de que en el modelo de regresión creado los valores de &lt;strong&gt;W&lt;/strong&gt; y &lt;strong&gt;b&lt;/strong&gt; se dejaron fijos en 16.0 y 10.0 respectivamente.&lt;/p&gt;
&lt;p&gt;Es por eso que el entrenamiento de los modelos es de suma importancia en todo algorimto de aprendizaje y conceptos como función de coste, errore medio cuadratico, descenso del gradiente entre otros empiezan a aparecer para facilitar la vida al momento de predecir.&lt;/p&gt;
&lt;p&gt;#Entrenamiento del modelo de regresión&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;print(&#39;valores reales    &#39;,X[:4].numpy(),&#39;\nValores predichos &#39;,modelo(X)[:4].numpy())
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;valores reales     [-0.98775786 -0.4940117  -1.1781967  -0.46405175] 
Valores predichos  [-5.804126   2.0958128 -8.851147   2.575172 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como se puede observar el error entre los valores reales y los valores predichos por el modelo son demasiado grandes es por eso que la grafica a quedado tan separada una de la otra. Con el fin de ajustar los valores y reducir esa discrepancia entre valores reales y predichos, se usan tecnicas que minimicen esos errores y son conocidas como funciones de coste &lt;em&gt;J&lt;/em&gt;, que para el caso de la regresión lineal se tiene la del &lt;strong&gt;error minimo cuadrado&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;$J = (y_{real} - y_{predicho})^{2}$&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def error_medio_cuadratico(y_real,y_predicho):
  return tf.reduce_mean(tf.square(y_real-y_predicho)) # error
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Como la tasa de errores se obtiene haciendo la diferencia de cada valor, se aplica la media de todos los errores de &lt;strong&gt;Y_real&lt;/strong&gt; y &lt;strong&gt;Y_predicho&lt;/strong&gt; con el objetivo de tener un solo valor que es el que se ira a sumar o restar a los pesos y bias para que estos se actualicen.
seriá algo asi&lt;/p&gt;
&lt;p&gt;$W (+/-) error   $  y  $ b (+/-) error$&lt;/p&gt;
&lt;p&gt;Pero como saber si se debe sumar o restar el erro a los pesos, es aqui donde entra una de los conceptos mas interesantes del aprendizaje de maquinas que es el calculo de la derivada de la funcion de coste con respecto a los pesos. Uno de los metodos mas usados para realizar esto es la optimización del gradiente descendiente. Con esta técnica conseguimos definir dos cosas&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;La direccion del cambio, saber si debo aumentar o disminuir los pesos&lt;/li&gt;
&lt;li&gt;La magnitud del cambio, saber si se disminuye mucho o se aumenta mucho el valor&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;El primer item se soluciona con el calculo del gradiente, ya para el segundo es necesario adicionar un parámetro mas a nuestro algoritmmo de aprendizaje que es la tasa de aprendizaje que generalmente esta configurada entre 0 y 1.&lt;/p&gt;
&lt;p&gt;Calcularemos el gradiente con las funciones ofrecidas por tensorflow.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def entrenamiento(modelo,X,y,tasa_aprendizaje=0.01):
  with tf.GradientTape() as t:
    error_actual=error_medio_cuadratico(y ,modelo(X))
  derivada_W, derivada_b = t.gradient(error_actual,[modelo.W,modelo.b])  
  modelo.W.assign_sub(tasa_aprendizaje*derivada_W)
  modelo.b.assign_sub(tasa_aprendizaje*derivada_b)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ahora con nuestra función de entrenamiento que contiene la actualizacion de pesos podremos mejorar el cálculo de nuestro modelo de regresión, para eso crearemos un loop con un determinado número de iteraciones para que los pesos se actualicen correctamente&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# en estas variables guardaremos los valores de los pesos de cada pasada 
ws,bs = [],[]
numero_itraciones=10
for iteracion in range(numero_itraciones):
  ws.append(modelo.W.numpy())
  bs.append(modelo.b.numpy())

  error_actual = error_medio_cuadratico(y,modelo(X))

  entrenamiento(modelo,X,y,tasa_aprendizaje=0.1)
  print(&amp;quot;Iteración {}, perdida {}&amp;quot;.format(iteracion, error_actual.numpy()))
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Iteración 0, perdida 255.19960021972656
Iteración 1, perdida 165.8444366455078
Iteración 2, perdida 107.90821838378906
Iteración 3, perdida 70.342041015625
Iteración 4, perdida 45.98304748535156
Iteración 5, perdida 30.187406539916992
Iteración 6, perdida 19.94432830810547
Iteración 7, perdida 13.301708221435547
Iteración 8, perdida 8.9938383102417
Iteración 9, perdida 6.2000041007995605
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como se puede observar la error despues de varias iteraciones disminuye considerablemnte eso quieres decir que la red esta aprendiendo a ajustar los pesos y generalizarlos a los ideales&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import matplotlib.pyplot as plt
#grafica de los valores historicos reales
plt.scatter(X,y, label=&amp;quot;valores reales&amp;quot;)
#grafica de los valores predichos por el modelo
plt.scatter(X,modelo(X), label = &amp;quot;valores predichos&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.collections.PathCollection at 0x7f18ddeda3c8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../figs/Machine_learning_I_35_1.png&#34; alt=&#34;png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ahora se puede observar que los puntos de la linea azul se aproximan bastante a la linea originial naranja. es por eso que es importante la etapa de entrenamiento en modelos de machine learning.&lt;/p&gt;
&lt;p&gt;Sin embargo, este es un modelo de regresión para funciones linealmente separables como el caso de la compuerta &lt;strong&gt;and&lt;/strong&gt; pero si el problema representa funciones no linealmente separables, sera que un solo perceptron es suficiente para hacer los calculos.&lt;/p&gt;
&lt;p&gt;La respuesta es no, para eso se conectan multiples neurones en multiples capas intercaonectados unos con otros formando lo que conocemos como redes neuronales. Que será explicado en el notebook Machine Learning II&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
